# -*- coding: utf-8 -*-
"""Missed_Better_Passes.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fQpwShRQANmvhFgf4GVc6zzlo6iQJhWM
"""

pip install mplsoccer

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from mplsoccer import Pitch


# Define the path to your data files in Google Drive
data_path = '/content/drive/My Drive/Football_Data/'

# Load the event data
events = pd.read_csv(data_path + 'Sample_Game_1_RawEventsData.csv')

# Load the tracking data for both teams
tracking_home = pd.read_csv(data_path + 'Sample_Game_1_RawTrackingData_Home_Team.csv')
tracking_away = pd.read_csv(data_path + 'Sample_Game_1_RawTrackingData_Away_Team.csv')

# You can now proceed with your analysis
events.head()

tracking_home.tail()

tracking_away.head()

"""	‚Ä¢	Home always attacks left ‚Üí right (x increasing).
	‚Ä¢	Away always attacks right ‚Üí left (x decreasing).

That way you don‚Äôt need to normalize pass-by-pass later. This is the cleanest approach for scalability.

‚∏ª

‚öôÔ∏è Transformation Rules
	‚Ä¢	Events dataset
	‚Ä¢	If Period == 2:
	‚Ä¢	For Home team ‚Üí x = 1 - x, y = 1 - y.
	‚Ä¢	For Away team ‚Üí same flip (so that both teams get reoriented consistently).
	‚Ä¢	Tracking datasets (home + away)
	‚Ä¢	For every frame in Period 2 ‚Üí flip all (x, y) coordinates.

‚∏ª

üìù Code to Standardize Datasets
"""

def flip_coords(x, y):
    """Flip coordinates horizontally + vertically."""
    return 1 - x, 1 - y

# --- 1. Events Dataset ---
def normalize_events(events):
    events = events.copy()
    for idx, row in events.iterrows():
        if row['Period'] == 2:  # 2nd half
            # Flip start coords
            events.at[idx, 'Start X'], events.at[idx, 'Start Y'] = flip_coords(row['Start X'], row['Start Y'])
            # Flip end coords
            events.at[idx, 'End X'], events.at[idx, 'End Y'] = flip_coords(row['End X'], row['End Y'])
    return events

# --- 2. Tracking Dataset ---
def normalize_tracking(tracking):
    tracking = tracking.copy()
    for idx, row in tracking.iterrows():
        if row['Period'] == 2:
            for col in tracking.columns:
                if '_x' in col:
                    y_col = col.replace('_x', '_y')
                    # Check if the corresponding y column exists before accessing
                    if y_col in tracking.columns:
                        tracking.at[idx, col], tracking.at[idx, y_col] = flip_coords(
                            row[col], row[y_col]
                        )
    return tracking

# Apply transformations
events_norm = normalize_events(events)
tracking_home_norm = normalize_tracking(tracking_home)
tracking_away_norm = normalize_tracking(tracking_away)

"""üìÇ Step 1: Initialize Structure"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from mplsoccer import Pitch

# Example: pick one pass event
pass_event = events_norm.iloc[3]   # row 3 = a PASS in your sample printout, with Start Frame 45
frame_id = pass_event['Start Frame']
team = pass_event['Team']
passer_id = pass_event['From']
receiver_id = pass_event['To']

print(f"Analyzing pass from {passer_id} to {receiver_id} at frame {frame_id}")

# --- Step 1: Extract player positions at this frame ---
if team == "Home":
    teammates_tracking = tracking_home_norm[tracking_home_norm['Frame'] == frame_id]
    opponents_tracking = tracking_away_norm[tracking_away_norm['Frame'] == frame_id]
    team_prefix = "Home_"
    opponent_prefix = "Away_"
else:
    teammates_tracking = tracking_away_norm[tracking_away_norm['Frame'] == frame_id]
    opponents_tracking = tracking_home_norm[tracking_home_norm['Frame'] == frame_id]
    team_prefix = "Away_"
    opponent_prefix = "Home_"


# Flatten row into dictionary {player_id: (x, y)}
teammate_positions = {}
for col in teammates_tracking.columns:
    if '_x' in col:
        player_id = col.split('_')[1]
        x_col = col
        y_col = col.replace('_x', '_y')
        if y_col in teammates_tracking.columns: # Check if y column exists
            teammate_positions[player_id] = (teammates_tracking.iloc[0][x_col], teammates_tracking.iloc[0][y_col])

opponent_positions = []
for col in opponents_tracking.columns:
    if '_x' in col:
        x_col = col
        y_col = col.replace('_x', '_y')
        if y_col in opponents_tracking.columns: # Check if y column exists
            opponent_positions.append((opponents_tracking.iloc[0][x_col], opponents_tracking.iloc[0][y_col]))


# Remove NaNs (players not on pitch)
teammate_positions = {pid: (x, y) for pid, (x, y) in teammate_positions.items() if not np.isnan(x)}
opponent_positions = [(x, y) for (x, y) in opponent_positions if not np.isnan(x)]

# --- Step 2: Identify passer coordinates ---
# Find the passer's position in the teammate_positions dictionary
passer_position = teammate_positions.get(passer_id.replace(team_prefix, ''))
if passer_position is None:
    print(f"Passer {passer_id} not found in tracking data for frame {frame_id}. Cannot analyze pass.")
    # Handle the case where the passer is not found, perhaps skip this event or use event data coordinates
    start_x, start_y = pass_event['Start X'], pass_event['Start Y'] # Use event data coordinates if tracking is missing
else:
    start_x, start_y = passer_position


# --- Step 3: Candidate passes (to all teammates except passer) ---
candidates = {pid: (x, y) for pid, (x, y) in teammate_positions.items() if f"{team}_{pid}" != passer_id}

# --- Step 4: Feasibility check: is pass blocked? ---
def point_line_distance(px, py, x1, y1, x2, y2):
    """Shortest distance from point (px,py) to line segment (x1,y1)-(x2,y2)."""
    A = px - x1
    B = py - y1
    C = x2 - x1
    D = y2 - y1

    dot = A*C + B*D
    len_sq = C*C + D*D
    param = dot / len_sq if len_sq != 0 else -1

    if param < 0:
        xx, yy = x1, y1
    elif param > 1:
        xx, yy = x2, y2
    else:
        xx, yy = x1 + param*C, y1 + param*D

    dx = px - xx
    dy = py - yy
    return np.sqrt(dx*dx + dy*dy)

feasible_passes = {}
for pid, (end_x, end_y) in candidates.items():
    blocked = False
    for (dx, dy) in opponent_positions:
        # Ensure opponent coordinates are not NaN before calculating distance
        if not np.isnan(dx) and not np.isnan(dy):
            if point_line_distance(dx, dy, start_x, start_y, end_x, end_y) < 0.02:  # threshold (scaled to pitch coords 0‚Äì1)
                blocked = True
                break
    if not blocked:
        feasible_passes[pid] = (end_x, end_y)

# --- Step 5: Visualization ---
pitch = Pitch(pitch_type='opta', line_zorder=2)
fig, ax = pitch.draw(figsize=(8, 5))

# Plot passer
ax.scatter(start_x, start_y, c='blue', s=80, label="Passer")

# Plot teammates
for pid, (x, y) in teammate_positions.items():
    ax.scatter(x, y, c='cyan', s=50)

# Plot defenders
for (dx, dy) in opponent_positions:
    ax.scatter(dx, dy, c='red', s=50)

# Actual chosen pass
# Ensure end coordinates from pass_event are not NaN before plotting
end_x_actual, end_y_actual = pass_event['End X'], pass_event['End Y']
if not np.isnan(end_x_actual) and not np.isnan(end_y_actual):
    ax.arrow(start_x, start_y,
             end_x_actual - start_x, end_y_actual - start_y,
             width=0.002, head_width=0.02, color='green', label="Chosen Pass")
else:
    print("Actual pass end coordinates are NaN. Cannot plot the actual pass.")


# Feasible alternative passes
for pid, (end_x, end_y) in feasible_passes.items():
    ax.arrow(start_x, start_y, end_x-start_x, end_y-start_y,
             width=0.001, head_width=0.015, color='orange', linestyle='--')

ax.legend()
plt.show()

"""üß© Step 2: Fill with Direct Event Data

From events you can directly map:
	‚Ä¢	player_from, player_to
	‚Ä¢	start_x, start_y, end_x, end_y
	‚Ä¢	timestamp, frame_id
	‚Ä¢	team (Home/Away)

And generate pass_id:
"""

home_counter, away_counter = 1, 1

def generate_pass_id(team):
    global home_counter, away_counter
    if team == "Home":
        pid = f"H{home_counter}"
        home_counter += 1
    else:
        pid = f"A{away_counter}"
        away_counter += 1
    return pid

"""üßÆ Step 3: Derived Metrics (functions)
	1.	Distance
"""

def pass_distance(x1, y1, x2, y2):
    return ((x2-x1)**2 + (y2-y1)**2) ** 0.5

"""#	2.	Direction (relative to goal axis)"""

import math


def pass_angle(x1, y1, x2, y2):
    dx, dy = x2 - x1, y2 - y1
    return np.degrees(np.arctan2(dy, dx))

def pass_direction(x1, y1, x2, y2):
    """Categorize pass as Forward, Backward, Sideways."""
    angle = pass_angle(x1, y1, x2, y2)
    if -45 <= angle <= 45:
        return "Forward"
    elif angle >= 135 or angle <= -135:
        return "Backward"
    else:
        return "Sideways"

"""3.	Possession Order

	‚Ä¢	Reset to 1 when possession changes.
"""

def pass_possession_index(events):
    """
    Count passes only within a possession.
    Resets when possession changes (Team switches).
    """
    indices = []
    current_team = None
    counter = 0

    for _, row in events.iterrows():
        if row['Team'] != current_team:
            current_team = row['Team']
            counter = 0
        if row['Type'] == "PASS":
            counter += 1
            indices.append(counter)
        else:
            indices.append(np.nan)
    return indices

"""4.	Line Break

	‚Ä¢	Define defensive lines (e.g. using y-coordinates of defenders sorted by depth).
	‚Ä¢	Check if receiver‚Äôs x-position is ‚Äúbeyond‚Äù at least one opponent line.
(Simple version: if receiver_x is behind median defender_x ‚Üí line broken.)
"""

def is_line_break(end_x, defenders_x):
    return end_x > sorted(defenders_x)[len(defenders_x)//2]  # simplified

"""5.	xT Calculation

	‚Ä¢	Use SoccerAction library (socceraction.xthreat) for state-of-art xT.
"""

pip install mplsoccer

import numpy as np

# ------------------
# Build xT Grid
# ------------------
def build_xT_grid(n_x=16, n_y=12):
    """
    Build a simple heuristic xT grid (closer to goal = higher xT).
    Later this can be replaced with a trained grid from shots data.
    """
    pitch_x = np.linspace(0, 1, n_x + 1)
    pitch_y = np.linspace(0, 1, n_y + 1)
    xT_grid = np.zeros((n_x, n_y))

    for i in range(n_x):
        for j in range(n_y):
            x_center = (pitch_x[i] + pitch_x[i+1]) / 2
            y_center = (pitch_y[j] + pitch_y[j+1]) / 2
            # heuristic: reward being closer to opponent‚Äôs goal center
            if x_center > 0:
                xT_grid[i, j] = (x_center**2 + (y_center - 0.5)**2) ** -0.5
            else:
                xT_grid[i, j] = 0
    return xT_grid


# ------------------
# Helper Functions
# ------------------
def get_cell(x, y, n_x=16, n_y=12):
    """Return grid cell indices for normalized (x,y)."""
    cell_x = min(int(x * n_x), n_x - 1)
    cell_y = min(int(y * n_y), n_y - 1)
    return cell_x, cell_y


def compute_xT_gain(start_x, start_y, end_x, end_y, xT_grid, n_x=16, n_y=12):
    """Return xT gain for a pass."""
    start_cell = get_cell(start_x, start_y, n_x, n_y)
    end_cell = get_cell(end_x, end_y, n_x, n_y)
    start_value = xT_grid[start_cell]
    end_value = xT_grid[end_cell]
    return end_value - start_value

def get_cell(x, y, n_x=16, n_y=12):
    """Return grid cell indices for normalized (x,y)."""
    cell_x = min(int(x * n_x), n_x - 1)
    cell_y = min(int(y * n_y), n_y - 1)
    return cell_x, cell_y

def compute_xT(start_x, start_y, end_x, end_y):
    """Return xT gain for a pass."""
    start_cell = get_cell(start_x, start_y)
    end_cell = get_cell(end_x, end_y)
    start_value = xT_grid[start_cell]
    end_value = xT_grid[end_cell]
    return end_value - start_value

"""üìå Step 4: Embedding Player Positions
	‚Ä¢	At frame_id, extract all (x, y) from tracking_home + tracking_away.
	‚Ä¢	Store as a dict or a mini DataFrame.
"""

def extract_positions(frame, tracking_home, tracking_away, allow_nearest=True):
    """Return dict of positions keyed by 'H{pid}'/'A{pid}'.
       Falls back to nearest frame if exact not found."""

    # Helper to get row from tracking
    def get_row(tracking, frame):
        row = tracking[tracking['Frame'] == frame]
        if not row.empty:
            return row.iloc[0]
        elif allow_nearest:
            idx = (tracking['Frame'] - frame).abs().idxmin()
            return tracking.loc[idx]
        return None

    home_row = get_row(tracking_home, frame)
    away_row = get_row(tracking_away, frame)

    pos = {}
    if home_row is not None:
        for col in tracking_home.columns:
            if col.endswith('_x'):
                pid = col.split('_')[1]
                ycol = col.replace('_x', '_y')
                if ycol in tracking_home.columns:
                    x_val, y_val = home_row[col], home_row[ycol]
                    if not (np.isnan(x_val) or np.isnan(y_val)):
                        pos[f"H{pid}"] = (x_val, y_val)

    if away_row is not None:
        for col in tracking_away.columns:
            if col.endswith('_x'):
                pid = col.split('_')[1]
                ycol = col.replace('_x', '_y')
                if ycol in tracking_away.columns:
                    x_val, y_val = away_row[col], away_row[ycol]
                    if not (np.isnan(x_val) or np.isnan(y_val)):
                        pos[f"A{pid}"] = (x_val, y_val)

    return pos

def build_pass_snapshots(events, tracking_home, tracking_away, xT_grid, n_x=16, n_y=12):
    snapshots = []
    home_counter, away_counter = 1, 1

    events = events.copy()
    events["possession_pass_index"] = pass_possession_index(events)

    for _, row in events.iterrows():
        if row['Type'] != "PASS":
            continue

        team = row['Team']
        passer, receiver = row['From'], row['To']
        start_x, start_y = row['Start X'], row['Start Y']
        end_x, end_y = row['End X'], row['End Y']
        frame_id, timestamp = row['Start Frame'], row['Start Time [s]']

        if team == "Home":
            pass_id = f"H{home_counter}"
            home_counter += 1
        else:
            pass_id = f"A{away_counter}"
            away_counter += 1

        distance = pass_distance(start_x, start_y, end_x, end_y)
        direction = pass_direction(start_x, start_y, end_x, end_y)
        xT_gain = compute_xT_gain(start_x, start_y, end_x, end_y, xT_grid, n_x, n_y)
        events = events.copy()
        try:
            positions = extract_positions(frame_id, tracking_home, tracking_away)
        except:
            positions = {}

        snapshots.append({
            "pass_id": pass_id,
            "team": team,
            "player_from": passer,
            "player_to": receiver,
            "frame_id": frame_id,
            "timestamp": timestamp,
            "start_x": start_x, "start_y": start_y,
            "end_x": end_x, "end_y": end_y,
            "distance": distance,
            "direction": direction,
            "possession_pass_index": row['possession_pass_index'],
            "xT_gain": xT_gain,
            "player_positions": positions
        })

    return pd.DataFrame(snapshots)

# Build heuristic xT grid
xT_grid = build_xT_grid(n_x=16, n_y=12)

# Build pass snapshots with xT gain
pass_snapshots = build_pass_snapshots(events_norm, tracking_home_norm, tracking_away_norm, xT_grid)

# Preview
pass_snapshots.head(10)

import numpy as np

# --- 1. Passing Lane Openness ---
# --- Feasibility Sub-scores ---
def passing_lane_openness(passer, receiver, defenders, threshold=0.02):
    """Score how open the lane is (1 = clear, 0 = blocked)."""
    x1, y1 = passer
    x2, y2 = receiver
    lane_clear = 1.0
    for (dx, dy) in defenders:
        A, B = dx - x1, dy - y1
        C, D = x2 - x1, y2 - y1
        dot = A*C + B*D
        len_sq = C*C + D*D
        param = dot / len_sq if len_sq != 0 else -1
        if param < 0:
            xx, yy = x1, y1
        elif param > 1:
            xx, yy = x2, y2
        else:
            xx, yy = x1 + param*C, y1 + param*D
        dist = np.sqrt((dx-xx)**2 + (dy-yy)**2)
        if dist < threshold:
            lane_clear *= (dist / threshold)  # shrink score
    return lane_clear

# --- 2. Receiver Advantage (Pitch Control Lite) ---
def receiver_advantage(receiver, defenders):
    """Receiver safer if further from nearest defender."""
    rx, ry = receiver
    if not defenders:
        return 1.0
    min_def_dist = min(np.sqrt((rx-dx)**2 + (ry-dy)**2) for dx, dy in defenders)
    if min_def_dist <= 0:
        return 0.0
    return min_def_dist / (min_def_dist + 0.1)  # logistic-like scaling

# --- 3. Distance Factor ---
def distance_factor(passer, receiver, max_distance=1.0):
    """Shorter passes score closer to 1."""
    dist = np.sqrt((receiver[0]-passer[0])**2 + (receiver[1]-passer[1])**2)
    return max(0.0, 1.0 - dist/max_distance)

def feasibility_score(passer, receiver, defenders):
    """Combine subscores."""
    return passing_lane_openness(passer, receiver, defenders) * \
           receiver_advantage(receiver, defenders) * \
           distance_factor(passer, receiver)

# def find_feasible_passes(snapshot, xT_grid, threshold=0.1):
#     """
#     snapshot: one row from pass_snapshots (dict-like).
#     xT_grid: the xT grid built earlier.
#     threshold: min feasibility score.
#
#     Returns list of dicts with feasible passes (target, feasibility, xT_gain).
#     """
#     passer_id = snapshot["player_from"]
#     positions = snapshot["player_positions"]  # dict {pid: (x,y)}
#
#     # Identify passer coordinates
#     passer_num = ''.join([c for c in str(passer_id) if c.isdigit()])
#     team_prefix = "H" if snapshot["team"] == "Home" else "A"
#     passer_key = team_prefix + passer_num
#     passer = positions.get(passer_key, (snapshot["start_x"], snapshot["start_y"]))
#
#     # Build defenders list
#     defenders = [(x,y) for pid,(x,y) in positions.items() if not pid.startswith(team_prefix)]
#
#     # Compute start_xT at passer location
#     # start_xT = xt_model.predict([passer[0]], [passer[1]])[0] # This line was causing the error
#
#     # Loop over teammates
#     feasible = []
#     for pid, (x,y) in positions.items():
#         if pid == passer_key:
#             continue  # skip self
#         score = feasibility_score(passer, (x,y), defenders)
#         if score >= threshold:
#             # Compute xT gain
#             xT_gain = compute_xT(snapshot["start_x"], snapshot["start_y"], x, y, xT_grid)
#             feasible.append({
#                 "target_id": pid,
#                 "target_pos": (x,y),
#                 "feasibility": score,
#                 "xT_gain": xT_gain,
#                 "combined_value": score * xT_gain  # optional: weighted tactical value
#             })
#     # Sort options: best first
#     feasible.sort(key=lambda d: d["xT_gain"], reverse=True)
#     return feasible

# Build the global grid once
xT_grid = build_xT_grid(n_x=16, n_y=12)

def compute_xT(start_x, start_y, end_x, end_y, xT_grid=xT_grid):
    """Return xT gain for a pass."""
    start_cell = get_cell(start_x, start_y)
    end_cell = get_cell(end_x, end_y)
    start_value = xT_grid[start_cell]
    end_value = xT_grid[end_cell]
    return end_value - start_value

# --- Main Snapshot Function ---
def build_feasible_passes_snapshot(pass_id, pass_snapshots, tracking_home, tracking_away, xT_grid, threshold=0.1):
    """
    Return DataFrame with actual + feasible passes for a given pass_id.
    """
    base_pass = pass_snapshots[pass_snapshots['pass_id'] == pass_id].iloc[0]
    frame_id, team = base_pass['frame_id'], base_pass['team']
    passer_id = base_pass['player_from']  # e.g., "Player9"

    # Normalize key for passer (events ‚Üí tracking ids)
    team_prefix = "H" if team == "Home" else "A"
    passer_num = ''.join([c for c in str(passer_id) if c.isdigit()])
    passer_key = team_prefix + passer_num

    # Extract positions
    positions = extract_positions(frame_id, tracking_home, tracking_away)
    passer_pos = positions.get(passer_key, (base_pass['start_x'], base_pass['start_y']))

    # Split players
    teammates = {pid: pos for pid, pos in positions.items() if pid.startswith(team_prefix) and pid != passer_key}
    defenders = [(x, y) for pid, (x, y) in positions.items() if not pid.startswith(team_prefix)]

    # Actual pass row
    feasible_passes = [{
        "pass_id": pass_id,
        "team": team,
        "player_from": passer_key,
        "player_to": team_prefix + ''.join([c for c in str(base_pass["player_to"]) if c.isdigit()]),
        "frame_id": frame_id,
        "timestamp": base_pass["timestamp"],
        "start_x": passer_pos[0], "start_y": passer_pos[1],
        "end_x": base_pass["end_x"], "end_y": base_pass["end_y"],
        "distance": base_pass["distance"],
        "direction": base_pass["direction"],
        "xT_gain": base_pass["xT_gain"],
        "feasibility": 1.0,
        "is_actual": True
    }]

    # Candidate feasible passes
    for pid, (tx, ty) in teammates.items():
        score = feasibility_score(passer_pos, (tx, ty), defenders)
        if score >= threshold:
            xT_gain = compute_xT(passer_pos[0], passer_pos[1], tx, ty, xT_grid)
            feasible_passes.append({
                "pass_id": pass_id + "_" + pid,
                "team": team,
                "player_from": passer_key,
                "player_to": pid,
                "frame_id": frame_id,
                "timestamp": base_pass["timestamp"],
                "start_x": passer_pos[0], "start_y": passer_pos[1],
                "end_x": tx, "end_y": ty,
                "distance": pass_distance(passer_pos[0], passer_pos[1], tx, ty),
                "direction": pass_direction(passer_pos[0], passer_pos[1], tx, ty),
                "xT_gain": xT_gain,
                "feasibility": score,
                "is_actual": False
            })

    return pd.DataFrame(feasible_passes)

snapshot_H1 = build_feasible_passes_snapshot("A22", pass_snapshots, tracking_home_norm, tracking_away_norm, xT_grid)
snapshot_H1

def find_passes_with_better_alternatives(pass_snapshots, tracking_home, tracking_away, xT_grid, threshold=0.1):
    """
    Find passes where there is at least one feasible alternative pass
    with a higher xT gain than the actual pass.

    Returns a list of pass_ids that meet the criteria.
    """
    passes_with_better_alternatives = []

    for _, base_pass in pass_snapshots.iterrows():
        pass_id = base_pass['pass_id']

        # Build feasible passes snapshot for the current pass
        feasible_passes_df = build_feasible_passes_snapshot(
            pass_id, pass_snapshots, tracking_home, tracking_away, xT_grid, threshold
        )

        # Separate actual pass and feasible alternatives
        actual_pass = feasible_passes_df[feasible_passes_df['is_actual']].iloc[0]
        feasible_alternatives = feasible_passes_df[~feasible_passes_df['is_actual']]

        # Check if there is at least one feasible alternative
        if not feasible_alternatives.empty:
            # Check if any feasible alternative has a higher xT gain than the actual pass
            if (feasible_alternatives['xT_gain'] > actual_pass['xT_gain']).any():
                passes_with_better_alternatives.append(pass_id)

    return passes_with_better_alternatives

# Find the pass_ids that meet the criteria
pass_ids_with_better_alternatives = find_passes_with_better_alternatives(
    pass_snapshots, tracking_home_norm, tracking_away_norm, xT_grid
)

# Display the pass_ids
print("Pass IDs with at least one feasible alternative with higher xT gain:")
print(pass_ids_with_better_alternatives)

# Optionally, you can retrieve the full snapshots for these pass_ids
# snapshots_with_better_alternatives = pass_snapshots[pass_snapshots['pass_id'].isin(pass_ids_with_better_alternatives)]
# display(snapshots_with_better_alternatives)

# Build heuristic xT grid
xT_grid = build_xT_grid(n_x=16, n_y=12)

# Build pass snapshots with xT gain
pass_snapshots = build_pass_snapshots(events_norm, tracking_home_norm, tracking_away_norm, xT_grid)

# Preview
pass_snapshots.head(10)

# Find the pass_ids that meet the criteria
pass_ids_with_better_alternatives = find_passes_with_better_alternatives(
    pass_snapshots, tracking_home_norm, tracking_away_norm, xT_grid
)

# Display the pass_ids
print("Pass IDs with at least one feasible alternative with higher xT gain:")
print(pass_ids_with_better_alternatives)

# Optionally, you can retrieve the full snapshots for these pass_ids
# snapshots_with_better_alternatives = pass_snapshots[pass_snapshots['pass_id'].isin(pass_ids_with_better_alternatives)]
# display(snapshots_with_better_alternatives)

def find_passes_with_better_alternatives(pass_snapshots, tracking_home, tracking_away, xT_grid, threshold=0.1):
    """
    Find passes where there is at least one feasible alternative pass
    with a higher xT gain than the actual pass.

    Returns a list of pass_ids that meet the criteria.
    """
    passes_with_better_alternatives = []

    for _, base_pass in pass_snapshots.iterrows():
        pass_id = base_pass['pass_id']

        # Build feasible passes snapshot for the current pass
        feasible_passes_df = build_feasible_passes_snapshot(
            pass_id, pass_snapshots, tracking_home_norm, tracking_away_norm, xT_grid, threshold
        )

        # Separate actual pass and feasible alternatives
        actual_pass = feasible_passes_df[feasible_passes_df['is_actual']].iloc[0]
        feasible_alternatives = feasible_passes_df[~feasible_passes_df['is_actual']]

        # Check if there is at least one feasible alternative
        if not feasible_alternatives.empty:
            # Check if any feasible alternative has a higher xT gain than the actual pass
            if (feasible_alternatives['xT_gain'] > actual_pass['xT_gain']).any():
                passes_with_better_alternatives.append(pass_id)

    return passes_with_better_alternatives

import matplotlib.pyplot as plt
from mplsoccer import Pitch
import ipywidgets as widgets
from ipywidgets import HBox, VBox, Output

def plot_pass_map(pass_df, pass_id, tracking_home_norm, tracking_away_norm):
    """
    Interactive pass map for one pass snapshot.
    """
    # --- Extract info ---
    actual = pass_df[pass_df["is_actual"]].iloc[0]
    team = actual["team"]
    frame_id = actual["frame_id"]
    timestamp = actual["timestamp"]

    # Get player positions from tracking for that frame
    frame_home_data = tracking_home_norm[tracking_home_norm['Frame'] == frame_id].iloc[0]
    frame_away_data = tracking_away_norm[tracking_away_norm['Frame'] == frame_id].iloc[0]

    # --- Pitch setup ---
    pitch = Pitch(pitch_type='statsbomb', pitch_color='black', line_color='white')
    fig, ax = pitch.draw(figsize=(12, 8))

    # --- Title left, arrow right ---
    fig.text(0.1, 0.95, f"Pass Map: {pass_id} | Time: {timestamp:.2f}s",
             color="white", fontsize=16, ha="left", va="center")

    if team == "Home":
        fig.text(0.8, 0.95, "Home attacking ‚Üí", color="white",
                 fontsize=12, ha="right", va="center")
    else:
        fig.text(0.8, 0.95, "Away attacking ‚Üê", color="white",
                 fontsize=12, ha="right", va="center")

    # --- Extract player positions safely ---
    home_player_coords, away_player_coords = [], []
    for col in frame_home_data.index:
        if col.endswith('_x'):
            y_col = col.replace('_x', '_y')
            if (y_col in frame_home_data.index and
                not pd.isna(frame_home_data[col]) and
                not pd.isna(frame_home_data[y_col])):
                home_player_coords.append((frame_home_data[col], frame_home_data[y_col]))
    for col in frame_away_data.index:
        if col.endswith('_x'):
            y_col = col.replace('_x', '_y')
            if (y_col in frame_away_data.index and
                not pd.isna(frame_away_data[col]) and
                not pd.isna(frame_away_data[y_col])):
                away_player_coords.append((frame_away_data[col], frame_away_data[y_col]))

    # --- Widgets ---
    toggle_actual = widgets.Checkbox(value=True, description="Actual Pass", indent=False)
    toggle_better = widgets.Checkbox(value=True, description="Better Alternatives", indent=False)
    toggle_all = widgets.Checkbox(value=False, description="All Feasible Passes", indent=False)

    out = Output()

    def update_plot(change=None):
        with out:
            out.clear_output(wait=True)
            fig, ax = pitch.draw(figsize=(12, 8))

            # Title left
            fig.text(0.1, 0.95, f"Pass Map: {pass_id} | Time: {timestamp:.2f}s",
                     color="white", fontsize=16, ha="left", va="center")

            # Arrow right
            if team == "Home":
                fig.text(0.8, 0.95, "Home attacking ‚Üí", color="white",
                         fontsize=12, ha="right", va="center")
            else:
                fig.text(0.8, 0.95, "Away attacking ‚Üê", color="white",
                         fontsize=12, ha="right", va="center")

            # replot base players
            ax.scatter([x*120 for x,y in home_player_coords],
                       [y*80 for x,y in home_player_coords],
                       color="blue", s=150, label="Home")
            ax.scatter([x*120 for x,y in away_player_coords],
                       [y*80 for x,y in away_player_coords],
                       color="red", s=150, label="Away")

            # plot passes
            if toggle_all.value:
                for _, row in pass_df.iterrows():
                    ax.arrow(row["start_x"]*120, row["start_y"]*80,
                             (row["end_x"]-row["start_x"])*120,
                             (row["end_y"]-row["start_y"])*80,
                             color="white", alpha=0.4, width=0.5, head_width=2, zorder=1)

            if toggle_actual.value:
                ax.arrow(actual["start_x"]*120, actual["start_y"]*80,
                         (actual["end_x"]-actual["start_x"])*120,
                         (actual["end_y"]-actual["start_y"])*80,
                         color="gold", width=1.5, head_width=3, zorder=3)
                ax.text((actual["start_x"]+actual["end_x"])/2*120,
                        (actual["start_y"]+actual["end_y"])/2*80,
                        f"xT {actual['xT_gain']:.3f}",
                        color="gold", fontsize=10, ha="center", va="center", zorder=4)

            if toggle_better.value:
                better = pass_df[(~pass_df["is_actual"]) & (pass_df["xT_gain"] > actual["xT_gain"])]
                for _, row in better.iterrows():
                    ax.arrow(row["start_x"]*120, row["start_y"]*80,
                             (row["end_x"]-row["start_x"])*120,
                             (row["end_y"]-row["start_y"])*80,
                             color="lime", width=1.2, head_width=3, alpha=0.8, zorder=2)
                    ax.text((row["start_x"]+row["end_x"])/2*120,
                            (row["start_y"]+row["end_y"])/2*80,
                            f"xT {row['xT_gain']:.3f}",
                            color="lime", fontsize=9, ha="center", va="center", zorder=3)

            plt.show()

    toggle_actual.observe(update_plot, names="value")
    toggle_better.observe(update_plot, names="value")
    toggle_all.observe(update_plot, names="value")

    update_plot()
    display(VBox([HBox([toggle_actual, toggle_better, toggle_all]), out]))

PI = "A1"
plot_pass_map(build_feasible_passes_snapshot(PI, pass_snapshots, tracking_home_norm, tracking_away_norm, xT_grid), PI, tracking_home_norm, tracking_away_norm)

snapshot_A1 = build_feasible_passes_snapshot("A1", pass_snapshots, tracking_home_norm, tracking_away_norm, xT_grid)
snapshot_A1

PI = "A28"
plot_pass_map(build_feasible_passes_snapshot(PI, pass_snapshots, tracking_home_norm, tracking_away_norm, xT_grid), PI, tracking_home_norm, tracking_away_norm)

snapshot_PI = build_feasible_passes_snapshot(PI, pass_snapshots, tracking_home_norm, tracking_away_norm, xT_grid)
snapshot_PI

!jupyter nbconvert --to script Missed_Better_Passes.ipynb

def plot_pass_map(pass_df, pass_id, tracking_home_norm, tracking_away_norm,
                  show_actual=True, show_better=True, show_all=False):
    """
    Returns a matplotlib figure for a pass map snapshot.
    Works with Streamlit checkboxes instead of ipywidgets.
    """

    import matplotlib.pyplot as plt
    from mplsoccer import Pitch

    # Extract actual pass
    actual = pass_df[pass_df["is_actual"]].iloc[0]
    team = actual["team"]
    frame_id = actual["frame_id"]

    # Frame player data
    frame_home_data = tracking_home_norm[tracking_home_norm['Frame'] == frame_id].iloc[0]
    frame_away_data = tracking_away_norm[tracking_away_norm['Frame'] == frame_id].iloc[0]

    # Setup pitch
    pitch = Pitch(pitch_type='statsbomb', pitch_color='black', line_color='white')
    fig, ax = pitch.draw(figsize=(12, 8))
    fig.suptitle(f"Pass Map: {pass_id} | Time: {actual['timestamp']:.2f}s",
                 color="white", fontsize=16, y=0.95)

    # Direction of play indicator
    if team == "Home":
        ax.arrow(0.2, 1.05, 0.6, 0, transform=ax.transAxes,
                 color="white", width=0.01, head_width=0.05)
        ax.text(0.5, 1.08, "Home attacking ‚Üí", transform=ax.transAxes,
                ha="center", va="center", color="white", fontsize=12)
    else:
        ax.arrow(0.8, 1.05, -0.6, 0, transform=ax.transAxes,
                 color="white", width=0.01, head_width=0.05)
        ax.text(0.5, 1.08, "Away attacking ‚Üê", transform=ax.transAxes,
                ha="center", va="center", color="white", fontsize=12)

    # Extract coordinates
    home_player_coords = [
        (frame_home_data[col], frame_home_data[col.replace('_x', '_y')])
        for col in frame_home_data.index if col.endswith('_x')
        and not pd.isna(frame_home_data[col])
        and not pd.isna(frame_home_data[col.replace('_x', '_y')])
    ]
    away_player_coords = [
        (frame_away_data[col], frame_away_data[col.replace('_x', '_y')])
        for col in frame_away_data.index if col.endswith('_x')
        and not pd.isna(frame_away_data[col])
        and not pd.isna(frame_away_data[col.replace('_x', '_y')])
    ]

    # Plot players
    ax.scatter([x*120 for x,y in home_player_coords], [y*80 for x,y in home_player_coords],
               color="blue", s=150, label="Home")
    ax.scatter([x*120 for x,y in away_player_coords], [y*80 for x,y in away_player_coords],
               color="red", s=150, label="Away")

    # Actual pass
    if show_actual:
        ax.arrow(actual["start_x"]*120, actual["start_y"]*80,
                 (actual["end_x"]-actual["start_x"])*120,
                 (actual["end_y"]-actual["start_y"])*80,
                 color="gold", width=1.5, head_width=3, zorder=3)
        ax.text((actual["start_x"]+actual["end_x"])/2*120,
                (actual["start_y"]+actual["end_y"])/2*80,
                f"xT {actual['xT_gain']:.3f}",
                color="gold", fontsize=10, ha="center", va="center", zorder=4)

    # Better passes
    if show_better:
        better = pass_df[(~pass_df["is_actual"]) & (pass_df["xT_gain"] > actual["xT_gain"])]
        for _, row in better.iterrows():
            ax.arrow(row["start_x"]*120, row["start_y"]*80,
                     (row["end_x"]-row["start_x"])*120,
                     (row["end_y"]-row["start_y"])*80,
                     color="lime", width=1.2, head_width=3, alpha=0.8, zorder=2)
            ax.text((row["start_x"]+row["end_x"])/2*120,
                    (row["start_y"]+row["end_y"])/2*80,
                    f"xT {row['xT_gain']:.3f}",
                    color="lime", fontsize=9, ha="center", va="center", zorder=3)

    # All feasible passes
    if show_all:
        for _, row in pass_df.iterrows():
            ax.arrow(row["start_x"]*120, row["start_y"]*80,
                     (row["end_x"]-row["start_x"])*120,
                     (row["end_y"]-row["start_y"])*80,
                     color="white", alpha=0.4, width=0.5, head_width=2, zorder=1)

    return fig

